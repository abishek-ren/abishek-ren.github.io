<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ” Object Detector</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    html, body { height: 100%; }

    body {
      background: #0f1117;
      color: #e2e8f0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      flex-shrink: 0;
      padding: 14px 24px;
      background: #1a1d27;
      border-bottom: 1px solid #2d3148;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    header h1 { font-size: 1.25rem; font-weight: 600; color: #a5b4fc; }
    header .subtitle { font-size: 0.78rem; color: #64748b; }

    #status-pill {
      margin-left: auto;
      font-size: 0.75rem;
      padding: 4px 12px;
      border-radius: 999px;
      background: #1e293b;
      color: #94a3b8;
      border: 1px solid #334155;
    }
    #status-pill.running { background: #052e16; color: #4ade80; border-color: #166534; }
    #status-pill.loading { background: #1e1a05; color: #fbbf24; border-color: #92400e; }

    main {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    /* â”€â”€ Camera â”€â”€ */
    #camera-wrap {
      flex: 1;
      position: relative;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #video {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      color: #475569;
    }
    #placeholder svg { width: 72px; height: 72px; opacity: .35; }
    #placeholder p { font-size: 0.9rem; }

    /* â”€â”€ Sidebar â”€â”€ */
    #sidebar {
      width: 280px;
      flex-shrink: 0;
      background: #1a1d27;
      border-left: 1px solid #2d3148;
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #sidebar-header {
      flex-shrink: 0;
      padding: 14px 16px;
      border-bottom: 1px solid #2d3148;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    #sidebar-header h2 {
      font-size: 0.8rem;
      font-weight: 700;
      color: #94a3b8;
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    #obj-count {
      font-size: 0.72rem;
      background: #312e81;
      color: #a5b4fc;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 600;
    }

    #object-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      min-height: 0;
    }
    #object-list::-webkit-scrollbar { width: 4px; }
    #object-list::-webkit-scrollbar-track { background: transparent; }
    #object-list::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

    .obj-item {
      display: flex;
      flex-direction: column;
      gap: 5px;
      padding: 9px 10px;
      background: #0d1117;
      border: 1px solid #21262d;
      border-radius: 8px;
      flex-shrink: 0;
    }

    .obj-item-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .obj-label {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: capitalize;
      flex: 1;
    }

    .obj-score {
      font-size: 0.72rem;
      color: #94a3b8;
      min-width: 34px;
      text-align: right;
    }

    .obj-bar-wrap {
      height: 3px;
      background: #21262d;
      border-radius: 2px;
      overflow: hidden;
    }
    .obj-bar {
      height: 100%;
      border-radius: 2px;
      transition: width .4s ease;
    }

    .emotion-section {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      border-top: 1px solid #21262d;
      padding-top: 6px;
    }

    .emotion-section-title {
      font-size: 0.68rem;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: .06em;
      margin-bottom: 2px;
    }

    .emo-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .emo-row.dominant .emo-label { color: #c4b5fd; font-weight: 700; }

    .emo-label {
      font-size: 0.72rem;
      color: #64748b;
      width: 72px;
      flex-shrink: 0;
      text-transform: capitalize;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .emo-bar-wrap {
      flex: 1;
      height: 5px;
      background: #21262d;
      border-radius: 3px;
      overflow: hidden;
    }
    .emo-bar {
      height: 100%;
      border-radius: 3px;
      transition: width .4s ease;
    }
    .emo-row.dominant .emo-bar { background: #818cf8; }
    .emo-bar { background: #334155; }

    .emo-pct {
      font-size: 0.68rem;
      color: #64748b;
      width: 28px;
      text-align: right;
      flex-shrink: 0;
    }
    .emo-row.dominant .emo-pct { color: #a5b4fc; }

    .empty-msg {
      color: #475569;
      font-size: 0.83rem;
      text-align: center;
      margin-top: 36px;
      line-height: 1.6;
    }

    /* â”€â”€ Controls â”€â”€ */
    #controls {
      flex-shrink: 0;
      padding: 10px 12px;
      border-top: 1px solid #2d3148;
      display: flex;
      gap: 7px;
    }

    button {
      flex: 1;
      padding: 9px;
      border: none;
      border-radius: 8px;
      font-size: 0.83rem;
      font-weight: 600;
      cursor: pointer;
      transition: opacity .15s;
    }
    button:hover:not(:disabled) { opacity: .85; }
    button:disabled { opacity: .4; cursor: not-allowed; }

    #btn-start { background: #4f46e5; color: #fff; }
    #btn-pause { background: #78350f; color: #fcd34d; }
    #btn-stop  { background: #1e293b; color: #94a3b8; }

    #footer-info {
      flex-shrink: 0;
      font-size: 0.68rem;
      color: #475569;
      text-align: center;
      padding: 3px 12px 6px;
      display: flex;
      justify-content: space-between;
    }
  </style>
</head>
<body>

<header>
  <span style="font-size:1.35rem">ğŸ”</span>
  <h1>Object Detector</h1>
  <span class="subtitle">COCO-SSD + Emotion Detection</span>
  <div id="status-pill">Idle</div>
</header>

<main>
  <div id="camera-wrap">
    <div id="placeholder">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.2">
        <path d="M15 10l4.553-2.276A1 1 0 0121 8.723v6.554a1 1 0 01-1.447.894L15 14M3 8a2 2 0 012-2h10a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2V8z"/>
      </svg>
      <p>Click <strong>Start</strong> to begin</p>
    </div>
    <video id="video" autoplay muted playsinline style="display:none"></video>
    <canvas id="canvas"></canvas>
  </div>

  <aside id="sidebar">
    <div id="sidebar-header">
      <h2>Detected Objects</h2>
      <span id="obj-count">0</span>
    </div>
    <div id="object-list">
      <p class="empty-msg">No objects detected yet.</p>
    </div>
    <div id="footer-info">
      <span id="fps-label"></span>
      <span id="emotion-status"></span>
    </div>
    <div id="controls">
      <button id="btn-start">â–¶ Start</button>
      <button id="btn-pause" disabled>â¸ Pause</button>
      <button id="btn-stop" disabled>â¹ Stop</button>
    </div>
  </aside>
</main>

<script>
  const video         = document.getElementById('video');
  const canvas        = document.getElementById('canvas');
  const ctx           = canvas.getContext('2d');
  const placeholder   = document.getElementById('placeholder');
  const objList       = document.getElementById('object-list');
  const objCount      = document.getElementById('obj-count');
  const statusPill    = document.getElementById('status-pill');
  const fpsLabel      = document.getElementById('fps-label');
  const emotionStatus = document.getElementById('emotion-status');
  const btnStart      = document.getElementById('btn-start');
  const btnPause      = document.getElementById('btn-pause');
  const btnStop       = document.getElementById('btn-stop');
  const cameraWrap    = document.getElementById('camera-wrap');

  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let cocoModel     = null;
  let faceModelsLoaded = false;
  let stream        = null;
  let running       = false;
  let paused        = false;
  let rafId         = null;
  let detectTimer   = null;

  // Latest predictions from COCO-SSD (used by render loop)
  let lastPredictions = [];
  // Map: label -> { score, color, emotion, lastSeen }
  const seenObjects = new Map();
  const OBJECT_TTL  = 2500;

  // FPS tracking
  let fpsFrames = 0, fpsLast = 0;

  // â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const colorCache = {};
  function labelColor(label) {
    if (!colorCache[label]) {
      let h = 0;
      for (let i = 0; i < label.length; i++) h = (h * 31 + label.charCodeAt(i)) & 0xFFFF;
      colorCache[label] = `hsl(${h % 360}, 70%, 62%)`;
    }
    return colorCache[label];
  }

  const EMOTION_EMOJI = {
    happy: 'ğŸ˜„', sad: 'ğŸ˜¢', angry: 'ğŸ˜ ',
    fearful: 'ğŸ˜¨', disgusted: 'ğŸ¤¢', surprised: 'ğŸ˜²', neutral: 'ğŸ˜'
  };

  function dominantEmotion(expressions) {
    return Object.entries(expressions).reduce((a, b) => a[1] > b[1] ? a : b)[0];
  }

  function setStatus(text, cls) {
    statusPill.textContent = text;
    statusPill.className = cls || '';
  }

  // â”€â”€ Model loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function loadModels() {
    setStatus('Loading modelsâ€¦', 'loading');
    btnStart.disabled = true;

    // Load COCO-SSD
    cocoModel = await cocoSsd.load();

    // Load face-api models (tinyFaceDetector + faceExpression)
    const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';
    try {
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
      ]);
      faceModelsLoaded = true;
      emotionStatus.textContent = 'ğŸ˜Š emotions ready';
    } catch (e) {
      console.warn('face-api models failed to load:', e);
      emotionStatus.textContent = 'âš ï¸ emotions failed';
      emotionStatus.style.color = '#f87171';
    }

    btnStart.disabled = false;
    setStatus('Ready', '');
  }

  // â”€â”€ Detection loop (runs on interval, independent of render) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let isDetecting = false;

  async function runDetection() {
    if (!running || paused || isDetecting || video.readyState < 2) return;
    isDetecting = true;
    try {
      const predictions = await cocoModel.detect(video);
      if (!running) { isDetecting = false; return; }

      const now = Date.now();

      // Update persistent object registry
      // Group predictions by label, keep highest score per label
      const bestPerLabel = {};
      predictions.forEach(p => {
        if (!bestPerLabel[p.class] || p.score > bestPerLabel[p.class].score)
          bestPerLabel[p.class] = p;
      });

      // Run face expression detection if a person was found
      let faceExpressions = null;
      if (faceModelsLoaded && bestPerLabel['person']) {
        try {
          const result = await faceapi
            .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.3 }))
            .withFaceExpressions();
          if (result) faceExpressions = result.expressions;
        } catch (_) {}
      }

      // Update seenObjects map
      for (const [lbl, pred] of Object.entries(bestPerLabel)) {
        const existing = seenObjects.get(lbl);
        seenObjects.set(lbl, {
          score: pred.score,
          color: labelColor(lbl),
          expressions: (lbl === 'person' && faceExpressions)
            ? faceExpressions
            : (existing ? existing.expressions : null),
          lastSeen: now,
        });
      }

      // Evict stale entries
      for (const [lbl, entry] of seenObjects)
        if (now - entry.lastSeen > OBJECT_TTL) seenObjects.delete(lbl);

      // Store for render loop
      lastPredictions = predictions;

      // Update sidebar
      renderSidebar();

    } catch (e) {
      console.error('Detection error:', e);
    }
    isDetecting = false;
  }

  // â”€â”€ Render loop (rAF, draws boxes each frame) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderFrame(ts) {
    if (!running) return;

    // FPS (only count when not paused)
    if (!paused) {
      fpsFrames++;
      if (ts - fpsLast >= 1000) {
        fpsLabel.textContent = `${fpsFrames} fps`;
        fpsFrames = 0;
        fpsLast = ts;
      }
    }

    // Sync canvas to container
    const wrapRect = cameraWrap.getBoundingClientRect();
    if (canvas.width !== wrapRect.width || canvas.height !== wrapRect.height) {
      canvas.width  = wrapRect.width;
      canvas.height = wrapRect.height;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (lastPredictions.length > 0 && video.videoWidth > 0) {
      const videoRect = video.getBoundingClientRect();
      const offsetX = videoRect.left - wrapRect.left;
      const offsetY = videoRect.top  - wrapRect.top;
      const scaleX  = videoRect.width  / video.videoWidth;
      const scaleY  = videoRect.height / video.videoHeight;

      lastPredictions.forEach(({ class: lbl, score, bbox }) => {
        const color = labelColor(lbl);
        const [x, y, w, h] = bbox;
        const sx = x * scaleX + offsetX;
        const sy = y * scaleY + offsetY;
        const sw = w * scaleX;
        const sh = h * scaleY;

        // Bounding box
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.strokeRect(sx, sy, sw, sh);

        // Build label text
        const entry = seenObjects.get(lbl);
        const dominant = entry?.expressions ? dominantEmotion(entry.expressions) : null;
        const emoji = dominant ? (EMOTION_EMOJI[dominant] || '') : '';
        const text  = `${lbl} ${Math.round(score * 100)}%${emoji ? ' ' + emoji : ''}`;

        ctx.font = 'bold 13px system-ui, sans-serif';
        const tw = ctx.measureText(text).width;
        const tagH = 22;

        // Tag background
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(sx, sy - tagH - 2, tw + 12, tagH, 4);
        ctx.fill();

        // Tag text
        ctx.fillStyle = '#000';
        ctx.fillText(text, sx + 6, sy - 7);
      });
    }

    rafId = requestAnimationFrame(renderFrame);
  }

  // â”€â”€ Sidebar render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function renderSidebar() {
    const sorted = [...seenObjects.entries()]
      .sort((a, b) => b[1].score - a[1].score);

    objCount.textContent = sorted.length;

    if (sorted.length === 0) {
      objList.innerHTML = '<p class="empty-msg">Scanningâ€¦<br><span style="font-size:.75rem">Point camera at objects</span></p>';
      return;
    }

    objList.innerHTML = sorted.map(([lbl, { score, color, expressions }]) => {
      const pct = Math.round(score * 100);

      // Build full emotion breakdown if this is a person with expressions
      let emotionHtml = '';
      if (expressions) {
        const dominant = dominantEmotion(expressions);
        const emoRows = Object.entries(expressions)
          .sort((a, b) => b[1] - a[1])
          .map(([emo, val]) => {
            const epct = Math.round(val * 100);
            const isDominant = emo === dominant;
            return `
              <div class="emo-row${isDominant ? ' dominant' : ''}">
                <span class="emo-label">${EMOTION_EMOJI[emo] || ''} ${emo}</span>
                <div class="emo-bar-wrap">
                  <div class="emo-bar" style="width:${epct}%${isDominant ? ';background:#818cf8' : ''}"></div>
                </div>
                <span class="emo-pct">${epct}%</span>
              </div>`;
          }).join('');
        emotionHtml = `
          <div class="emotion-section">
            <div class="emotion-section-title">Emotions</div>
            ${emoRows}
          </div>`;
      }

      return `
        <div class="obj-item">
          <div class="obj-item-row">
            <span class="obj-label" style="color:${color}">${lbl}</span>
            <span class="obj-score">${pct}%</span>
          </div>
          <div class="obj-bar-wrap">
            <div class="obj-bar" style="width:${pct}%;background:${color}"></div>
          </div>
          ${emotionHtml}
        </div>`;
    }).join('');
  }

  // â”€â”€ Start / Stop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function startDetection() {
    if (running) return;
    if (!cocoModel) await loadModels();

    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    } catch {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      } catch (err) {
        alert('Camera access denied: ' + err.message);
        return;
      }
    }

    video.srcObject = stream;
    await video.play();
    placeholder.style.display = 'none';
    video.style.display = 'block';

    running = true;
    paused  = false;
    btnStart.disabled = true;
    btnPause.disabled = false;
    btnStop.disabled  = false;
    setStatus('Running', 'running');

    // Render loop (every frame)
    rafId = requestAnimationFrame(renderFrame);

    // Detection loop (every 300ms â€” not tied to rAF)
    detectTimer = setInterval(runDetection, 300);
  }

  function stopDetection() {
    running = false;
    paused  = false;
    clearInterval(detectTimer);
    if (rafId) cancelAnimationFrame(rafId);
    if (stream) stream.getTracks().forEach(t => t.stop());

    stream = null;
    video.srcObject = null;
    video.style.display = 'none';
    placeholder.style.display = 'flex';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    lastPredictions = [];
    seenObjects.clear();

    objList.innerHTML = '<p class="empty-msg">No objects detected yet.</p>';
    objCount.textContent = '0';
    fpsLabel.textContent = '';
    btnStart.disabled = false;
    btnPause.disabled = true;
    btnPause.textContent = 'â¸ Pause';
    btnStop.disabled  = true;
    setStatus('Idle', '');
  }

  function togglePause() {
    if (!running) return;

    if (!paused) {
      // Pause: freeze video on current frame, stop detection updates
      paused = true;
      video.pause();
      fpsLabel.textContent = 'paused';
      btnPause.textContent = 'â–¶ Resume';
      btnPause.style.background = '#14532d';
      btnPause.style.color = '#86efac';
      setStatus('Paused', 'loading');
    } else {
      // Resume: unfreeze video and restart detection
      paused = false;
      video.play();
      fpsLabel.textContent = '';
      btnPause.textContent = 'â¸ Pause';
      btnPause.style.background = '';
      btnPause.style.color = '';
      setStatus('Running', 'running');
    }
  }

  btnStart.addEventListener('click', startDetection);
  btnPause.addEventListener('click', togglePause);
  btnStop.addEventListener('click',  stopDetection);

  // Pre-load models on page open
  loadModels();
</script>
</body>
</html>
